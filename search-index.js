var N = null;var searchIndex = {};
searchIndex["bv"]={"doc":"The main type exported by the library, [`BitVec`], is a packed, growable bit-vector. Its API mirrors that of `Vec` where reasonable.","items":[[3,"BitSlice","bv","A slice of a bit-vector; akin to `&'a [bool]` but packed.",N,N],[3,"BitSliceMut","","A mutable slice of a bit-vector; akin to `&'a mut [bool]` but packed.",N,N],[3,"BitVec","","A bit-vector, akin to `Vec<bool>` but packed.",N,N],[11,"from_slice","","Creates a `BitSlice` from an array slice of blocks.",0,N],[11,"from_raw_parts","","Creates a `BitSlice` from a pointer to its data, an offset where the bits start, and the number of available bits.",0,N],[11,"len","","The number of bits in the slice.",0,[[["self"]],["u64"]]],[11,"is_empty","","Returns whether there are no bits in the slice.",0,[[["self"]],["bool"]]],[11,"from_slice","","Creates a `BitSliceMut` from a mutable array slice of blocks.",1,N],[11,"from_raw_parts","","Creates a `BitSliceMut` from a pointer to its data, an offset where the bits start, and the number of available bits.",1,N],[11,"len","","The number of bits in the slice.",1,[[["self"]],["u64"]]],[11,"is_empty","","Returns whether there are no bits in the slice.",1,[[["self"]],["bool"]]],[11,"as_bit_slice","","Converts a mutable bit slice to immutable.",1,[[["self"]],["bitslice"]]],[11,"new","","Creates a new, empty bit-vector with a capacity of one block.",2,[[],["self"]]],[11,"with_capacity","","Creates a new, empty bit-vector with the given bit capacity.",2,[[["u64"]],["self"]]],[11,"with_block_capacity","","Creates a new, empty bit-vector with the given block capacity.",2,[[["usize"]],["self"]]],[11,"new_fill","","Creates a new bit-vector of size `len`, filled with all 0s or 1s depending on `value`.",2,[[["bool"],["u64"]],["self"]]],[11,"from_bits","","Creates a new `BitVec` from any value implementing the `Bits` trait with the same block type.",2,[[["b"]],["self"]]],[11,"len","","The number of bits in the bit-vector.",2,[[["self"]],["u64"]]],[11,"block_len","","The number of blocks used by this bit-vector.",2,[[["self"]],["usize"]]],[11,"capacity","","The capacity of the bit-vector in bits.",2,[[["self"]],["u64"]]],[11,"block_capacity","","The capacity of the bit-vector in blocks.",2,[[["self"]],["usize"]]],[11,"reserve","","Adjust the capacity to hold at least `additional` additional bits.",2,[[["self"],["u64"]]]],[11,"block_reserve","","Adjust the capacity to hold at least `additional` additional blocks.",2,[[["self"],["usize"]]]],[11,"reserve_exact","","Adjust the capacity to hold at least `additional` additional bits.",2,[[["self"],["u64"]]]],[11,"block_reserve_exact","","Adjusts the capacity to at least `additional` blocks beyond those used.",2,[[["self"],["usize"]]]],[11,"shrink_to_fit","","Shrinks the capacity of the vector as much as possible.",2,[[["self"]]]],[11,"into_boxed_slice","","Converts the vector into `Box<[Block]>`.",2,[[["self"]],["box"]]],[11,"truncate","","Shortens the vector, keeping the first `len` elements and dropping the rest.",2,[[["self"],["u64"]]]],[11,"resize","","Resizes the bit-vector, filling with `value` if it has to grow.",2,[[["self"],["u64"],["bool"]]]],[11,"as_slice","","Gets a slice to a `BitVec`.",2,[[["self"]],["bitslice"]]],[11,"as_mut_slice","","Gets a mutable slice to a `BitVec`.",2,[[["self"]],["bitslicemut"]]],[11,"get","","Gets the value of the bit at the given position.",2,[[["self"],["u64"]],["bool"]]],[11,"set","","Sets the value of the bit at the given position.",2,[[["self"],["u64"],["bool"]]]],[11,"push","","Adds the given `bool` to the end of the bit-vector.",2,[[["self"],["bool"]]]],[11,"pop","","Removes and returns the last element of the bit-vector, or `None` if empty.",2,[[["self"]],["option",["bool"]]]],[11,"clear","","Removes all elements from the bit-vector.",2,[[["self"]]]],[11,"is_empty","","Does the bit-vector have no elements?",2,[[["self"]],["bool"]]],[0,"adapter","","Lazy bit vector adapters.",N,N],[3,"BitSliceAdapter","bv::adapter","An adapter that turns any implementation of `Bits` into a slice.",N,N],[3,"BitNot","","The result of `BitsExt::bit_not`.",N,N],[3,"BitAnd","","The result of `BitsExt::bit_and`.",N,N],[3,"BitOr","","The result of `BitsExt::bit_or`.",N,N],[3,"BitXor","","The result of `BitsExt::bit_xor`.",N,N],[3,"BitZip","","The result of `BitsExt::bit_zip`.",N,N],[3,"BitFill","","Emulates a constant-valued bit-vector of a given size.",N,N],[3,"BitConcat","","The result of `BitsExt::bit_concat`.",N,N],[3,"BoolAdapter","","Adapts a sequence of `bool`s (e.g., `&[bool]`) to emulate a bit vector.",N,N],[11,"new","","Creates a new slice adaptor from the given bit-vector-like.",3,[[["t"],["u64"],["u64"]],["self"]]],[11,"zeroes","","Constructs a compact bit-vector-like of `len` 0s.",4,[[["u64"]],["self"]]],[11,"ones","","Constructs a compact bit-vector-like of `len` 1s.",4,[[["u64"]],["self"]]],[11,"new","","Creates a new `BoolAdapter` from an underlying sequence of `bool`s.",5,[[["t"]],["self"]]],[11,"into_inner","","Gets the underlying `bool` sequence object back out of a `BoolAdapter`.",5,[[["self"]],["t"]]],[8,"BlockType","bv","Interface to primitive bit storage.",N,N],[11,"nbits","","The number of bits in a block.",6,[[],["usize"]]],[11,"div_nbits","","Returns `index / Self::nbits()`, computed by shifting.",6,[[["u64"]],["usize"]]],[11,"checked_div_nbits","","Returns `index / Self::nbits()`, computed by shifting.",6,[[["u64"]],["option",["usize"]]]],[11,"ceil_div_nbits","","Returns `index / Self::nbits()` rounded up, computed by shifting.",6,[[["u64"]],["usize"]]],[11,"checked_ceil_div_nbits","","Returns `index / Self::nbits()` rounded up, computed by shifting.",6,[[["u64"]],["option",["usize"]]]],[11,"mod_nbits","","Returns `index % Self::nbits()`, computed by masking.",6,[[["u64"]],["usize"]]],[11,"mul_nbits","","Returns `index * Self::nbits()`, computed by shifting.",6,[[["usize"]],["u64"]]],[11,"block_bits","","The number of bits in the block at `position`, given a total bit length of `len`.",6,[[["u64"],["usize"]],["usize"]]],[11,"lg_nbits","","Log-base-2 of the number of bits in a block.",6,[[],["usize"]]],[11,"lg_nbits_mask","","Mask with the lowest-order `lg_nbits()` set.",6,[[],["result"]]],[11,"low_mask","","The bit mask consisting of `Self::nbits() - element_bits` zeroes followed by `element_bits` ones.",6,[[["usize"]],["self"]]],[11,"nth_mask","","The bit mask with the `bit_index`th bit set.",6,[[["usize"]],["self"]]],[11,"get_bit","","Extracts the value of the `bit_index`th bit.",6,[[["self"],["usize"]],["bool"]]],[11,"with_bit","","Functionally updates the value of the `bit_index`th bit to `bit_value`.",6,[[["self"],["usize"],["bool"]],["self"]]],[11,"get_bits","","Extracts `len` bits starting at bit offset `start`.",6,[[["self"],["usize"],["usize"]],["self"]]],[11,"with_bits","","Functionally updates `len` bits to `value` starting at offset `start`.",6,[[["self"],["usize"],["usize"],["self"]],["self"]]],[11,"ceil_lg","","Returns the smallest number `n` such that `2.pow(n) >= self`.",6,[[["self"]],["usize"]]],[11,"floor_lg","","Returns the largest number `n` such that `2.pow(n) <= self`.",6,[[["self"]],["usize"]]],[10,"wrapping_shl","","A shift-left operation that does not overflow.",6,[[["self"],["u32"]],["self"]]],[10,"wrapping_sub","","A subtraction operation that does not overflow.",6,[[["self"],["self"]],["self"]]],[10,"leading_zeros","","Returns the number of leading zero bits in the given number.",6,[[["self"]],["usize"]]],[10,"to_usize","","Converts the number to a `usize`, if it fits.",6,[[["self"]],["option",["usize"]]]],[10,"zero","","Returns 0.",6,[[],["self"]]],[10,"one","","Returns 1.",6,[[],["self"]]],[8,"Bits","","Read-only bit vector operations.",N,N],[16,"Block","","The underlying block type used to store the bits of the vector.",7,N],[10,"bit_len","","The length of the slice in bits.",7,[[["self"]],["u64"]]],[11,"block_len","","The length of the slice in blocks.",7,[[["self"]],["usize"]]],[11,"get_bit","","Gets the bit at `position`",7,[[["self"],["u64"]],["bool"]]],[11,"get_block","","Gets the block at `position`, masked as necessary.",7,N],[11,"get_raw_block","","Gets the block at `position`, without masking.",7,N],[11,"get_bits","","Gets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",7,N],[11,"to_bit_vec","","Copies the bits into a new allocated [`BitVec`].",7,[[["self"]],["bitvec"]]],[8,"BitsExt","","Extension trait for adapter operations on bit slices.",N,N],[11,"bit_concat","","Concatenates two bit vectors, with the bits of `self` followed by the bits of `other`.",8,[[["self"],["other"]],["bitconcat"]]],[11,"into_bit_concat","","Concatenates two bit vectors, with the bits of `self` followed by the bits of `other`.",8,[[["self"],["other"]],["bitconcat"]]],[11,"bit_pad","","Pads `self` with 0s on the right to reach at least `len` bits in length.",8,[[["self"],["u64"]],["bitconcat",["bitfill"]]]],[11,"into_bit_pad","","Pads `self` with 0s on the right to reach at least `len` bits in length.",8,[[["self"],["u64"]],["bitconcat",["bitfill"]]]],[11,"bit_not","","Returns an object that inverts the values of all the bits in `self`.",8,[[["self"]],["bitnot"]]],[11,"into_bit_not","","Returns an object that inverts the values of all the bits in `self`.",8,[[["self"]],["bitnot"]]],[11,"bit_and","","Returns an object that lazily computes the bit-wise conjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitand"]]],[11,"into_bit_and","","Returns an object that lazily computes the bit-wise conjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitand"]]],[11,"bit_or","","Returns an object that lazily computes the bit-wise disjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitor"]]],[11,"into_bit_or","","Returns an object that lazily computes the bit-wise disjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitor"]]],[11,"bit_xor","","Returns an object that lazily computes the bit-wise xor of two bit-vector-likes.",8,[[["self"],["other"]],["bitxor"]]],[11,"into_bit_xor","","Returns an object that lazily computes the bit-wise xor of two bit-vector-likes.",8,[[["self"],["other"]],["bitxor"]]],[11,"bit_zip","","Returns an object that lazily zips a function over the blocks of two bit-vector-like.",8,[[["self"],["other"],["f"]],["bitzip"]]],[11,"into_bit_zip","","Returns an object that lazily zips a function over the blocks of two bit-vector-like.",8,[[["self"],["other"],["f"]],["bitzip"]]],[8,"BitsMut","","Mutable bit vector operations that donâ€™t affect the length.",N,N],[11,"set_bit","","Sets the bit at `position` to `value`.",9,[[["self"],["u64"],["bool"]]]],[11,"set_block","","Sets the block at `position` to `value`.",9,N],[11,"set_bits","","Sets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",9,N],[8,"BitsMutExt","","Extension trait for mutable operations on bit slices.",N,N],[11,"bit_assign","","Assigns the bits of `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_and_assign","","Assigns the bit-wise and of `self` and `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_or_assign","","Assigns the bit-wise or of `self` and `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_xor_assign","","Assigns the bit-wise xor of `self` and `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_zip_assign","","Performs an op-assignment from `other` to `self`.",10,[[["self"],["t"],["f"]]]],[8,"BitsPush","","Bit vector operations that change the length.",N,N],[10,"push_bit","","Adds the given bit to the end of the bit vector.",11,[[["self"],["bool"]]]],[10,"pop_bit","","Removes and returns the last bit, if any.",11,[[["self"]],["option",["bool"]]]],[11,"align_block","","Pushes `value` 0 or more times until the size of the bit vector is block-aligned.",11,[[["self"],["bool"]]]],[11,"push_block","","Pushes the given block onto the end of the bit vector.",11,N],[8,"BitSliceable","","Types that support slicing by ranges.",N,N],[16,"Slice","","The type of the slice produced.",12,N],[10,"bit_slice","","Slices or re-slices the given object.",12,N],[8,"BitSliceableMut","","Types that produce mutable slices.",N,N],[11,"bit_slice_mut","","An alias for `BitSliceable::bit_slice`.",13,N],[14,"bit_vec","","Like `vec!` but for `BitVec`.",N,N],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","bv::adapter","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"bit_len","bv","",0,[[["self"]],["u64"]]],[11,"get_bit","","",0,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",0,[[["self"],["usize"]],["block"]]],[11,"get_raw_block","","",0,[[["self"],["usize"]],["block"]]],[11,"get_bits","","",0,N],[11,"bit_len","","",1,[[["self"]],["u64"]]],[11,"get_bit","","",1,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",1,[[["self"],["usize"]],["block"]]],[11,"get_bits","","",1,N],[11,"bit_len","","",2,[[["self"]],["u64"]]],[11,"get_bit","","",2,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",2,[[["self"],["usize"]],["block"]]],[11,"get_raw_block","","",2,[[["self"],["usize"]],["block"]]],[11,"bit_len","bv::adapter","",3,[[["self"]],["u64"]]],[11,"get_bit","","",3,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",3,N],[11,"get_bits","","",3,N],[11,"bit_len","","",14,[[["self"]],["u64"]]],[11,"get_bit","","",14,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",14,N],[11,"get_raw_block","","",14,N],[11,"bit_len","","",15,[[["self"]],["u64"]]],[11,"get_bit","","",15,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",15,N],[11,"get_raw_block","","",15,N],[11,"bit_len","","",16,[[["self"]],["u64"]]],[11,"get_bit","","",16,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",16,N],[11,"get_raw_block","","",16,N],[11,"bit_len","","",17,[[["self"]],["u64"]]],[11,"get_bit","","",17,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",17,N],[11,"get_raw_block","","",17,N],[11,"bit_len","","",18,[[["self"]],["u64"]]],[11,"get_block","","",18,N],[11,"get_raw_block","","",18,N],[11,"bit_len","","",4,[[["self"]],["u64"]]],[11,"get_bit","","",4,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",4,N],[11,"get_raw_block","","",4,N],[11,"get_bits","","",4,N],[11,"bit_len","","",19,[[["self"]],["u64"]]],[11,"get_bit","","",19,[[["self"],["u64"]],["bool"]]],[11,"get_block","","",19,N],[11,"bit_len","","",5,[[["self"]],["u64"]]],[11,"get_bit","","",5,[[["self"],["u64"]],["bool"]]],[11,"bit_len","","",5,[[["self"]],["u64"]]],[11,"get_bit","","",5,[[["self"],["u64"]],["bool"]]],[11,"bit_len","","",5,[[["self"]],["u64"]]],[11,"get_bit","","",5,[[["self"],["u64"]],["bool"]]],[11,"bit_len","","",5,[[["self"]],["u64"]]],[11,"get_bit","","",5,[[["self"],["u64"]],["bool"]]],[11,"set_bit","bv","",1,[[["self"],["u64"],["bool"]]]],[11,"set_block","","",1,[[["self"],["usize"],["block"]]]],[11,"set_bits","","",1,N],[11,"set_bit","","",2,[[["self"],["u64"],["bool"]]]],[11,"set_block","","",2,[[["self"],["usize"],["block"]]]],[11,"set_bit","bv::adapter","",3,[[["self"],["u64"],["bool"]]]],[11,"set_block","","",3,N],[11,"set_bits","","",3,N],[11,"set_bit","","",5,[[["self"],["u64"],["bool"]]]],[11,"set_bit","","",5,[[["self"],["u64"],["bool"]]]],[11,"set_bit","","",5,[[["self"],["u64"],["bool"]]]],[11,"push_bit","bv","",2,[[["self"],["bool"]]]],[11,"pop_bit","","",2,[[["self"]],["option",["bool"]]]],[11,"align_block","","",2,[[["self"],["bool"]]]],[11,"push_block","","",2,[[["self"],["block"]]]],[11,"push_bit","bv::adapter","",5,[[["self"],["bool"]]]],[11,"pop_bit","","",5,[[["self"]],["option",["bool"]]]],[11,"push_bit","","",5,[[["self"],["bool"]]]],[11,"pop_bit","","",5,[[["self"]],["option",["bool"]]]],[11,"bit_slice","bv","",0,[[["self"],["range",["u64"]]],["self"]]],[11,"bit_slice","","",1,[[["self"],["range",["u64"]]],["self"]]],[11,"bit_slice","","",0,[[["self"],["rangeinclusive",["u64"]]],["self"]]],[11,"bit_slice","","",1,[[["self"],["rangeinclusive",["u64"]]],["self"]]],[11,"bit_slice","","",0,[[["self"],["rangefrom",["u64"]]],["self"]]],[11,"bit_slice","","",1,[[["self"],["rangefrom",["u64"]]],["self"]]],[11,"bit_slice","","",0,[[["self"],["rangeto",["u64"]]],["self"]]],[11,"bit_slice","","",1,[[["self"],["rangeto",["u64"]]],["self"]]],[11,"bit_slice","","",0,[[["self"],["rangetoinclusive",["u64"]]],["self"]]],[11,"bit_slice","","",1,[[["self"],["rangetoinclusive",["u64"]]],["self"]]],[11,"bit_slice","","",0,[[["self"],["rangefull"]],["self"]]],[11,"bit_slice","","",1,[[["self"],["rangefull"]],["self"]]],[11,"bit_slice","bv::adapter","",3,N],[11,"bit_slice","","",3,N],[11,"bit_slice","","",3,N],[11,"bit_slice","","",3,N],[11,"bit_slice","","",3,N],[11,"bit_slice","","",3,N],[11,"bit_slice","","",14,N],[11,"bit_slice","","",15,N],[11,"bit_slice","","",16,N],[11,"bit_slice","","",17,N],[11,"bit_slice","","",18,N],[11,"bit_slice","","",4,N],[11,"bit_slice","","",4,N],[11,"bit_slice","","",4,N],[11,"bit_slice","","",4,N],[11,"bit_slice","","",4,N],[11,"bit_slice","","",4,N],[11,"bit_slice","","",19,N],[11,"bit_slice","","",19,N],[11,"bit_slice","","",19,N],[11,"bit_slice","","",19,N],[11,"bit_slice","","",19,N],[11,"bit_slice","","",19,N],[11,"default","bv","",2,[[],["self"]]],[11,"eq","","",0,[[["self"],["other"]],["bool"]]],[11,"eq","","",1,[[["self"],["other"]],["bool"]]],[11,"eq","","",2,[[["self"],["other"]],["bool"]]],[11,"eq","bv::adapter","",3,[[["self"],["u"]],["bool"]]],[11,"eq","","",14,[[["self"],["u"]],["bool"]]],[11,"eq","","",15,[[["self"],["v"]],["bool"]]],[11,"eq","","",16,[[["self"],["v"]],["bool"]]],[11,"eq","","",17,[[["self"],["v"]],["bool"]]],[11,"eq","","",18,[[["self"],["v"]],["bool"]]],[11,"eq","","",4,[[["self"],["t"]],["bool"]]],[11,"eq","","",19,[[["self"],["v"]],["bool"]]],[11,"eq","","",5,[[["self"],["u"]],["bool"]]],[11,"from","bv","",0,[[["bitslicemut"]],["self"]]],[11,"from","","",0,N],[11,"from","","",1,N],[11,"from","","",2,[[["box"]],["self"]]],[11,"from","","",2,[[["vec"]],["self"]]],[11,"clone","","",0,[[["self"]],["bitslice"]]],[11,"clone","","",2,[[["self"]],["bitvec"]]],[11,"clone","bv::adapter","",3,[[["self"]],["bitsliceadapter"]]],[11,"clone","","",14,[[["self"]],["bitnot"]]],[11,"clone","","",15,[[["self"]],["bitand"]]],[11,"clone","","",16,[[["self"]],["bitor"]]],[11,"clone","","",17,[[["self"]],["bitxor"]]],[11,"clone","","",18,[[["self"]],["bitzip"]]],[11,"clone","","",4,[[["self"]],["bitfill"]]],[11,"clone","","",19,[[["self"]],["bitconcat"]]],[11,"clone","","",5,[[["self"]],["booladapter"]]],[11,"cmp","bv","",0,[[["self"],["self"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["self"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["self"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"],["bitslice"]],["option",["ordering"]]]],[11,"partial_cmp","","",1,[[["self"],["bitslicemut"]],["option",["ordering"]]]],[11,"partial_cmp","","",2,[[["self"],["bitvec"]],["option",["ordering"]]]],[11,"deref","bv::adapter","",5,[[["self"]],["t"]]],[11,"fmt","bv","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","bv::adapter","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"deref_mut","","",5,[[["self"]],["t"]]],[11,"index","bv","",0,[[["self"],["u64"]],["bool"]]],[11,"index","","",1,[[["self"],["u64"]],["bool"]]],[11,"index","","",2,[[["self"],["u64"]],["bool"]]],[11,"index","bv::adapter","",3,[[["self"],["u64"]],["bool"]]],[11,"index","","",14,[[["self"],["u64"]],["bool"]]],[11,"index","","",15,[[["self"],["u64"]],["bool"]]],[11,"index","","",16,[[["self"],["u64"]],["bool"]]],[11,"index","","",17,[[["self"],["u64"]],["bool"]]],[11,"index","","",18,[[["self"],["u64"]],["bool"]]],[11,"index","","",4,[[["self"],["u64"]],["bool"]]],[11,"index","","",19,[[["self"],["u64"]],["bool"]]],[11,"hash","bv","",0,[[["self"],["h"]]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"hash","","",2,[[["self"],["h"]]]],[11,"nbits","","The number of bits in a block.",6,[[],["usize"]]],[11,"div_nbits","","Returns `index / Self::nbits()`, computed by shifting.",6,[[["u64"]],["usize"]]],[11,"checked_div_nbits","","Returns `index / Self::nbits()`, computed by shifting.",6,[[["u64"]],["option",["usize"]]]],[11,"ceil_div_nbits","","Returns `index / Self::nbits()` rounded up, computed by shifting.",6,[[["u64"]],["usize"]]],[11,"checked_ceil_div_nbits","","Returns `index / Self::nbits()` rounded up, computed by shifting.",6,[[["u64"]],["option",["usize"]]]],[11,"mod_nbits","","Returns `index % Self::nbits()`, computed by masking.",6,[[["u64"]],["usize"]]],[11,"mul_nbits","","Returns `index * Self::nbits()`, computed by shifting.",6,[[["usize"]],["u64"]]],[11,"block_bits","","The number of bits in the block at `position`, given a total bit length of `len`.",6,[[["u64"],["usize"]],["usize"]]],[11,"lg_nbits","","Log-base-2 of the number of bits in a block.",6,[[],["usize"]]],[11,"lg_nbits_mask","","Mask with the lowest-order `lg_nbits()` set.",6,[[],["result"]]],[11,"low_mask","","The bit mask consisting of `Self::nbits() - element_bits` zeroes followed by `element_bits` ones.",6,[[["usize"]],["self"]]],[11,"nth_mask","","The bit mask with the `bit_index`th bit set.",6,[[["usize"]],["self"]]],[11,"get_bit","","Extracts the value of the `bit_index`th bit.",6,[[["self"],["usize"]],["bool"]]],[11,"with_bit","","Functionally updates the value of the `bit_index`th bit to `bit_value`.",6,[[["self"],["usize"],["bool"]],["self"]]],[11,"get_bits","","Extracts `len` bits starting at bit offset `start`.",6,[[["self"],["usize"],["usize"]],["self"]]],[11,"with_bits","","Functionally updates `len` bits to `value` starting at offset `start`.",6,[[["self"],["usize"],["usize"],["self"]],["self"]]],[11,"ceil_lg","","Returns the smallest number `n` such that `2.pow(n) >= self`.",6,[[["self"]],["usize"]]],[11,"floor_lg","","Returns the largest number `n` such that `2.pow(n) <= self`.",6,[[["self"]],["usize"]]],[11,"block_len","","The length of the slice in blocks.",7,[[["self"]],["usize"]]],[11,"get_bit","","Gets the bit at `position`",7,[[["self"],["u64"]],["bool"]]],[11,"get_block","","Gets the block at `position`, masked as necessary.",7,N],[11,"get_raw_block","","Gets the block at `position`, without masking.",7,N],[11,"get_bits","","Gets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",7,N],[11,"to_bit_vec","","Copies the bits into a new allocated [`BitVec`].",7,[[["self"]],["bitvec"]]],[11,"bit_concat","","Concatenates two bit vectors, with the bits of `self` followed by the bits of `other`.",8,[[["self"],["other"]],["bitconcat"]]],[11,"into_bit_concat","","Concatenates two bit vectors, with the bits of `self` followed by the bits of `other`.",8,[[["self"],["other"]],["bitconcat"]]],[11,"bit_pad","","Pads `self` with 0s on the right to reach at least `len` bits in length.",8,[[["self"],["u64"]],["bitconcat",["bitfill"]]]],[11,"into_bit_pad","","Pads `self` with 0s on the right to reach at least `len` bits in length.",8,[[["self"],["u64"]],["bitconcat",["bitfill"]]]],[11,"bit_not","","Returns an object that inverts the values of all the bits in `self`.",8,[[["self"]],["bitnot"]]],[11,"into_bit_not","","Returns an object that inverts the values of all the bits in `self`.",8,[[["self"]],["bitnot"]]],[11,"bit_and","","Returns an object that lazily computes the bit-wise conjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitand"]]],[11,"into_bit_and","","Returns an object that lazily computes the bit-wise conjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitand"]]],[11,"bit_or","","Returns an object that lazily computes the bit-wise disjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitor"]]],[11,"into_bit_or","","Returns an object that lazily computes the bit-wise disjunction of two bit-vector-likes.",8,[[["self"],["other"]],["bitor"]]],[11,"bit_xor","","Returns an object that lazily computes the bit-wise xor of two bit-vector-likes.",8,[[["self"],["other"]],["bitxor"]]],[11,"into_bit_xor","","Returns an object that lazily computes the bit-wise xor of two bit-vector-likes.",8,[[["self"],["other"]],["bitxor"]]],[11,"bit_zip","","Returns an object that lazily zips a function over the blocks of two bit-vector-like.",8,[[["self"],["other"],["f"]],["bitzip"]]],[11,"into_bit_zip","","Returns an object that lazily zips a function over the blocks of two bit-vector-like.",8,[[["self"],["other"],["f"]],["bitzip"]]],[11,"set_bit","","Sets the bit at `position` to `value`.",9,[[["self"],["u64"],["bool"]]]],[11,"set_block","","Sets the block at `position` to `value`.",9,N],[11,"set_bits","","Sets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",9,N],[11,"bit_assign","","Assigns the bits of `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_and_assign","","Assigns the bit-wise and of `self` and `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_or_assign","","Assigns the bit-wise or of `self` and `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_xor_assign","","Assigns the bit-wise xor of `self` and `other` to `self`.",10,[[["self"],["t"]]]],[11,"bit_zip_assign","","Performs an op-assignment from `other` to `self`.",10,[[["self"],["t"],["f"]]]],[11,"align_block","","Pushes `value` 0 or more times until the size of the bit vector is block-aligned.",11,[[["self"],["bool"]]]],[11,"push_block","","Pushes the given block onto the end of the bit vector.",11,N],[11,"bit_slice_mut","","An alias for `BitSliceable::bit_slice`.",13,N]],"paths":[[3,"BitSlice"],[3,"BitSliceMut"],[3,"BitVec"],[3,"BitSliceAdapter"],[3,"BitFill"],[3,"BoolAdapter"],[8,"BlockType"],[8,"Bits"],[8,"BitsExt"],[8,"BitsMut"],[8,"BitsMutExt"],[8,"BitsPush"],[8,"BitSliceable"],[8,"BitSliceableMut"],[3,"BitNot"],[3,"BitAnd"],[3,"BitOr"],[3,"BitXor"],[3,"BitZip"],[3,"BitConcat"]]};
initSearch(searchIndex);
